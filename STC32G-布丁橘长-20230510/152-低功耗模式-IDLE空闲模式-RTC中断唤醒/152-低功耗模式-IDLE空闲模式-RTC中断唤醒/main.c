//	@布丁橘长 2023/04/10
//  低功耗模式：IDLE-空闲模式，以及唤醒示例:
//	P2口流水灯完成后，LED熄灭，进入空闲模式，短暂熄灭后，RTC秒中断唤醒，唤醒后，P2口循环流水灯
//  使用外部32.768KHz晶振，屠龙刀开发板上，需要断开R133
//	实验开发板：STC32G12K128屠龙刀三.1 主频@12MHz

#include <STC32G.H>
#include "config.h"
#include "delay.h"

void sysini(void);						// STC32初始化设置
void Blink();									// P2口流水灯
void RTC_config(void);				//RTC初始化设置
void main(void)
{
	sysini();										// STC32初始化设置
	RTC_config();								//RTC初始化设置
	
	EA = 1;											// 使能EA总中断
	
	Blink();										// 完成一次P2口流水灯
	P2 = 0xFF;									// 熄灭所有LED

	IDL = 1;										// 进入低功耗模式-IDLE空闲模式
	while (1)
	{
		Blink();									// P2口循环流水灯
	}
}
void RTC_Isr(void) interrupt 13		// 13号中断为保留中断，因为RTC中断号大于31，这里借用13号中断中转
{																	// 关于Keil中断号扩展详细信息，可以参照布丁橘长-STC32G系列视频第36期，或STC32G手册第5.9章节
	if(RTCIF & 0x80)   					//闹钟中断
	{
		RTCIF &= ~0x80;						//清零闹钟中断标志	
		// 用户代码
	}
	if(RTCIF & 0x40)						//日中断
	{
		RTCIF &= ~0x40;						//清零日中断标志
		//  用户代码
	}
	if(RTCIF & 0x20)						//小时中断
	{
		RTCIF &= ~0x20;						//清零小时中断标志
		//  用户代码
	}
	if(RTCIF & 0x10)						//分钟中断
	{
		RTCIF &= ~0x10;						//清零分钟中断标志
		//  用户代码
	}
	if(RTCIF & 0x08)   					//秒中断
	{
		RTCIF &= ~0x08;						//清零秒中断标志
		// 用户代码
	}
}

void sysini()
{
	EAXFR = 1; 									// 使能访问 XFR
	CKCON = 0x00; 							// 设置外部数据总线速度为最快
	WTST = 0x00;								// 设置程序代码等待参数，等待时间为0个时钟，CPU执行程序速度最快

	P0M1 = 0x00;P0M0 = 0x00;		// 设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P1M1 = 0x00;P1M0 = 0x00;		// 设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P2M1 = 0x00;P2M0 = 0x00;		// 设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P3M1 = 0x00;P3M0 = 0x00;		// 设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P4M1 = 0x00;P4M0 = 0x00;		// 设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P5M1 = 0x00;P5M0 = 0x00;		// 设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P6M1 = 0x00;P6M0 = 0x00;		// 设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P7M1 = 0x00;P7M0 = 0x00;		// 设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
}
void RTC_config(void)		//RTC初始化设置
{
    INIYEAR = 23;    		//Y:2023
    INIMONTH = 04;   		//M:04
    INIDAY = 11;     		//D:11
    INIHOUR = 22;    		//H:22
    INIMIN = 59;     		//M:59
    INISEC = 50;     		//S:55
    INISSEC = 0;      	//S/128:0

    ALAHOUR = 23;				//闹钟小时 		23时
    ALAMIN  = 0;				//闹钟分钟 		00分
    ALASEC  = 0;				//闹钟秒   		00秒
    ALASSEC = 0;				//闹钟1/128秒
	
    //STC32G 芯片使用内部32K时钟，休眠无法唤醒
		X32KCR = 0x80 + 0x40;   	//启动外部32K晶振, 低增益+0x00, 高增益+0x40.
    while (!(X32KCR & 1));  	//等待时钟稳定
		RTCCFG = 0x01;    				//选择外部32.768K时钟源，触发RTC寄存器初始化
	
    RTCIF = 0x00;     				//清中断标志
    RTCIEN = 0xF8;    				//中断使能, 0x80:闹钟中断, 0x40:日中断, 0x20:小时中断, 0x10:分钟中断, 0x08:秒中断, 0x04:1/2秒中断, 0x02:1/8秒中断, 0x01:1/32秒中断
    RTCCR = 0x01;     				//RTC使能
    while(RTCCFG & 0x01);			//等待初始化完成,需要在 "RTC使能" 之后判断. 
    //设置RTC时间需要32768Hz的1个周期时间,大约30.5us. 由于同步, 所以实际等待时间是0~30.5us.
}
void Blink()									// P2口流水灯
{
	u8 i;
	for(i = 0;i < 8;i++)
	{
		P2 = ~(0x01 << i);				// 移位法
		delayms(200);							// 延时200ms
	}
}