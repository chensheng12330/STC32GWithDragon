//	@布丁橘长 2023/02/20
//	内置RTC实时时钟-闹钟设置、闹钟中断、分中断、秒中断、1/8秒中断示例程序
//	设置了1个闹钟@23：00:00，设置了2次重复，23:00:00闹钟响后，每隔1分钟重复一次闹钟，重复2次
//	初始时间设置为：23年02月19日，23：45:55
//	8位MAX7219数码管模块显示，引脚定义：DIN = P6^6; CS = P6^5; CLK = P6^4;
//  有源蜂鸣器模块-引脚定义：BEEP = P2^0,低电平触发
//	实验开发板：STC32G12K128屠龙刀三.1 主频@12MHz

#include <STC32G.H>
#include "config.h"
#include "MAX7219.h"

sbit BEEP = P2^0;		

bit B_1ms;          //1ms标志
bit B_1s;						//1s标志
bit B_1min;					//1min标志
bit B_Alarm;        //闹钟标志
bit B_125ms;				//1/8s标志

void RTC_config(void);		//RTC初始化设置函数
void DISP_Clock(void);		//时钟显示函数

void main(void)
{
	u8 beepnums;		//1/8秒计数
	u8 secnums;			//1秒计数
	u8 alarmnums;		//闹钟次数
	u8 ALARM_REPEAT;		//闹钟重复次数
	
	EAXFR = 1; 			// 使能访问 XFR
	CKCON = 0x00; 	// 设置外部数据总线速度为最快
	WTST = 0x00;		// 设置程序代码等待参数，等待时间为0个时钟，CPU执行程序速度最快

	P0M1 = 0x00;P0M0 = 0x00;		//设置P0口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P1M1 = 0x00;P1M0 = 0x00;		//设置P1口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P2M1 = 0x00;P2M0 = 0x00;		//设置P2口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P3M1 = 0x00;P3M0 = 0x00;		//设置P3口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P4M1 = 0x00;P4M0 = 0x00;		//设置P4口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P5M1 = 0x00;P5M0 = 0x00;		//设置P5口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P6M1 = 0x00;P6M0 = 0x00;		//设置P6口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	P7M1 = 0x00;P7M0 = 0x00;		//设置P7口为准双向口模式 //00：准双向口 01：推挽输出 10：高阻输入 11：开漏输出
	
  RTC_config();								//RTC初始化配置
  EA = 1;     								//打开总中断
	Initial();									//MAX219初始化
	ALARM_REPEAT = 2;						//闹钟重复2次（闹钟+重复2次=3次）
	
  while(1)
  {
    DISP_Clock();							//显示时钟
		
		if((B_Alarm == 1) && (alarmnums <= ALARM_REPEAT))					//闹钟标志为1
		{
			if(B_125ms == 1)				//1/8秒计时到
			{
				if(beepnums > 8) beepnums = 0;	//8个1/8秒为1秒
				if(beepnums == 0 || beepnums == 2) BEEP = 0;	//0-1/8秒、1/8-3/8秒时蜂鸣器响两声
				else BEEP = 1;					//1秒内的其它时间，蜂鸣器不响
				beepnums++;							//1/8计时数++
				B_125ms = 0;						//清零1/8秒标志
			}
			if(B_1s == 1)							//1秒计时到
			{
				if(secnums > 10)				//如果大于10秒计时
				{
					secnums = 0;					//清零秒计时
					B_Alarm = 0;					//清零闹钟标志
					BEEP = 1;							//关闭蜂鸣器
					alarmnums++;
					B_1min = 0;
				}
				secnums++;							//秒计时+1
				B_1s = 0;								//清零1秒标志
			}
		}
		if(B_1min == 1 && alarmnums > 0)
		{
			B_Alarm = 1;//第一次闹钟中断后，每1分钟，重复一次闹钟
			B_1min = 0;
			secnums = 0;
		}
  }
} 
void DISP_Clock(void)
{							
	Write7219(8,(u8)(HOUR / 10)); //显示小时十位
	Write7219(7,(u8)(HOUR % 10)); //显示小时个位
	Write7219(6,10); 							//横杆
	Write7219(5,(u8)(MIN / 10));	//显示分钟十位 	
	Write7219(4,(u8)(MIN % 10)); 	//显示分钟个位
	Write7219(3,10); 							//横杆
	Write7219(2,(u8)(SEC / 10)); 	//显示秒钟十位		
	Write7219(1,(u8)(SEC % 10)); 	//显示秒钟个位
}
void RTC_Isr() interrupt 13			//借用13号保留中断的中断向量地址中转(RTC中断号原本是36)
{																//isr.asm中从 (RTC中断向量地址)0123H 跳转到 (13号保留中断向量地址)006BH
																//关于13号中断&Keil中断号拓展，详情参照STC32G系列视频第36期，或STC官方STC32G手册第5.9小节
	if(RTCIF & 0x80)   						//闹钟中断
	{
		RTCIF &= ~0x80;							//清零闹钟中断标志	
		B_Alarm = 1;								//闹钟标志置1
	}
	if(RTCIF & 0x10)							//分钟中断
	{
		RTCIF &= ~0x10;							//清零分钟中断标志
		B_1min = 1;									//1分钟标志置1
	}
	if(RTCIF & 0x08)   						//秒中断
	{
		RTCIF &= ~0x08;							//清零秒中断标志
		B_1s = 1;										//秒标志置1
	}
	if(RTCIF & 0x02)							//1/8s中断
	{
		RTCIF &= ~0x02;							//清零1/8秒中断标志
		B_125ms = 1;								//1/8秒标志置1
	}
}

void RTC_config(void)		//RTC初始化设置代码
{
    INIYEAR = 23;    		//Y:2023
    INIMONTH = 02;   		//M:02
    INIDAY = 19;     		//D:19
    INIHOUR = 22;    		//H:23
    INIMIN = 59;     		//M:59
    INISEC = 50;     		//S:55
    INISSEC = 0;      	//S/128:0

    ALAHOUR = 23;				//闹钟小时 		23时
    ALAMIN  = 0;				//闹钟分钟 		00分
    ALASEC  = 0;				//闹钟秒   		00秒
    ALASSEC = 0;				//闹钟1/128秒

    //STC32G 芯片使用内部32K时钟，休眠无法唤醒
		IRC32KCR = 0x80;   				//启动内部32K晶振.
    while (!(IRC32KCR & 1));  //等待时钟稳定
		RTCCFG = 0x03;    				//选择内部32K时钟源，触发RTC寄存器初始化

    RTCIF = 0x00;     				//清中断标志
    RTCIEN = 0x9A;    				//中断使能, 0x80:闹钟中断, 0x40:日中断, 0x20:小时中断, 0x10:分钟中断, 0x08:秒中断, 0x04:1/2秒中断, 0x02:1/8秒中断, 0x01:1/32秒中断
    RTCCR = 0x01;     				//RTC使能

    while(RTCCFG & 0x01);	//等待初始化完成,需要在 "RTC使能" 之后判断. 
    //设置RTC时间需要32768Hz的1个周期时间,大约30.5us. 由于同步, 所以实际等待时间是0~30.5us.
}
